"use server"

import { createServerClient } from "@supabase/ssr"
import { cookies } from "next/headers"
import { revalidatePath } from "next/cache"

export async function executeService(serviceId: string, prompt: string, cost: number) {
  const cookieStore = await cookies()
  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) => cookieStore.set(name, value, options))
          } catch {}
        },
      },
    },
  )

  const {
    data: { user },
  } = await supabase.auth.getUser()
  if (!user) throw new Error("Unauthorized")

  // Check balance
  const { data: creditData } = await supabase.from("user_credits").select("balance").eq("user_id", user.id).single()

  if (!creditData || creditData.balance < cost) {
    throw new Error("Insufficient credits")
  }

  // Deduct credits
  const { error: updateError } = await supabase
    .from("user_credits")
    .update({ balance: creditData.balance - cost })
    .eq("user_id", user.id)

  if (updateError) throw new Error("Failed to update credits")

  // Record transaction
  await supabase.from("transactions").insert({
    user_id: user.id,
    amount: -cost,
    type: "usage",
    description: `Used service: ${serviceId}`,
  })

  // Execute AI (Simulated for now if no API key, but using AI SDK structure)
  // In a real app, you would use the specific model for the service
  try {
    // We'll use a simple generation for demonstration.
    // If OPENAI_API_KEY is not set, this might fail, so we'll wrap in try/catch and fallback to mock.
    // For the purpose of this demo, I'll mock the response to ensure it works without keys.

    // const { text } = await generateText({
    //   model: openai("gpt-4o"),
    //   prompt: `Service: ${serviceId}\nPrompt: ${prompt}`,
    // })

    // Mock response for stability in demo environment
    await new Promise((resolve) => setTimeout(resolve, 2000)) // Simulate delay
    const text = `[AI Generated Content for ${serviceId}]\n\nBased on your prompt: "${prompt}"\n\nHere is the result generated by Nano Banana Pro AI. This is a simulated response to demonstrate the credit system and UI flow.`

    revalidatePath("/")
    return { success: true, data: text, remainingCredits: creditData.balance - cost }
  } catch (error) {
    // Refund on failure
    await supabase.from("user_credits").update({ balance: creditData.balance }).eq("user_id", user.id)

    throw new Error("AI Service failed")
  }
}

export async function addCredits(formData: FormData) {
  const amount = Number.parseInt(formData.get("amount") as string)

  const cookieStore = await cookies()
  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return cookieStore.getAll()
        },
        setAll(cookiesToSet) {
          try {
            cookiesToSet.forEach(({ name, value, options }) => cookieStore.set(name, value, options))
          } catch {}
        },
      },
    },
  )

  const {
    data: { user },
  } = await supabase.auth.getUser()
  if (!user) throw new Error("Unauthorized")

  // In a real app, this would redirect to Lemon Squeezy Checkout
  // For this demo, we'll just add the credits directly

  const { data: creditData } = await supabase.from("user_credits").select("balance").eq("user_id", user.id).single()

  if (creditData) {
    await supabase
      .from("user_credits")
      .update({ balance: creditData.balance + amount })
      .eq("user_id", user.id)

    await supabase.from("transactions").insert({
      user_id: user.id,
      amount: amount,
      type: "purchase",
      description: `Purchased ${amount} credits (Demo)`,
    })
  }

  revalidatePath("/billing")
  revalidatePath("/")
}
